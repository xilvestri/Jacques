#!/usr/bin/python
import Adafruit_BBIO.ADC as ADC
import Adafruit_BBIO.GPIO as GPIO
import Adafruit_BBIO.UART as UART
import serial

import time


Flame1 = "P9_40"
Flame2 = "P9_38"
Flame3 = "P9_36"
Status1="P8_11"
Status2="P8_12"
Status3="P8_13"
Status4="P8_14"
Status5="P8_17"
SButton= "P8_18"
ADC.setup()

Ultra1E="P9_15"
Ultra1T="P9_11"
Ultra2E="P9_27"
Ultra2T="P9_25"
Ultra3E="P8_16"
Ultra3T="P8_15"
Ultra4E="P9_16"
Ultra4T="P9_13"

GPIO.setup(Ultra1E, GPIO.IN)
GPIO.setup(Ultra1T, GPIO.OUT)
GPIO.setup(Ultra2E, GPIO.IN)
GPIO.setup(Ultra2T, GPIO.OUT)
GPIO.setup(Ultra3E, GPIO.IN)
GPIO.setup(Ultra3T, GPIO.OUT)
GPIO.setup(Ultra4E, GPIO.IN)
GPIO.setup(Ultra4T, GPIO.OUT)

GPIO.output(Ultra1T, GPIO.LOW)
GPIO.output(Ultra2T, GPIO.LOW)
GPIO.output(Ultra3T, GPIO.LOW)
GPIO.output(Ultra4T, GPIO.LOW)

UART.setup("UART1")
ser = serial.Serial(port = "/dev/ttyO1", baudrate = 9600)

ser.open()

Cflag = 0
blinkCount=0

def translate(value, leftMin, leftMax, rightMin, rightMax):
    # Figure out how 'wide' each range is
    leftSpan = leftMax - leftMin
    rightSpan = rightMax - rightMin

    # Convert the left range into a 0-1 range (float)
    valueScaled = float(value - leftMin) / float(leftSpan)

    # Convert the 0-1 range into a value in the right range.
    return rightMin + (valueScaled * rightSpan)

def readSonar(sensorTrig, sensorEcho):
    time.sleep(.01)
    signaloff=0
    signalon=0
    count = 0
    counte=0
    while(signaloff==0 and signalon ==0 and count < 1000):
        GPIO.output(sensorTrig, True)
        time.sleep(0.00001)
        GPIO.output(sensorTrig, False)
        
        while( GPIO.input(sensorEcho) == 0 and counte < 1000):
            signaloff = time.time()
            counte = counte+1
        counte=0
        
        while( GPIO.input(sensorEcho) == 1 and counte < 1000):
            signalon= time.time()
            counte = counte +1
        counte=0
        count = count + 1
        
        
    count = 0   
    timepassed = signalon - signaloff
        
    distance = timepassed *17000
    if signaloff==0 or signalon==0:
        distance = 0
    
    return distance
        
    GPIO.cleanup()
    

def search(state, max1, max2, max3, min1, min2, min3):
    
    Cflag = 0
    blinkCount=0
    while state == 4:
        if(blinkCount<=700):
             GPIO.output(Status2, GPIO.HIGH)
             blinkCount = blinkCount+1
        elif(700<blinkCount<=1400):
             GPIO.output(Status2, GPIO.LOW)
             blinkCount = blinkCount +1
        else:
            blinkCount=0
        
        
        if (GPIO.input(SButton) == 1 and Cflag == 0):
            print "driving driving driving"
            driveCom = "C"
            ser.write(driveCom)
            
          #-----------------------------------------------------------------------comment out when no ultras present 
            # SonarR = readSonar(Ultra1T, Ultra1E)
            # SonarL= readSonar(Ultra3T, Ultra3E)
            # SonarC = readSonar(Ultra2T, Ultra2E)
            # SonarB = readSonar(Ultra4T, Ultra4E)
            # lowest= min(SonarR, SonarL, SonarC, SonarB)
            # if lowest == 0:
            #     driveCom="F"
            #     ser.write(driveCom)
            #     while(1):
            #         GPIO.output(Status1, GPIO.HIGH)
            #         GPIO.output(Status2, GPIO.LOW)            #LED pattern for failed ultrasonic
            #         GPIO.output(Status3, GPIO.HIGH)
            #         GPIO.output(Status4, GPIO.LOW)
            #         GPIO.output(Status5, GPIO.HIGH)
                    
            # if lowest <= 25:
            #     driveCom="F"
            # ser.write(driveCom)
            
            
            #------------------------------------------------------------------comment out when no ultras present
            
            Flame1reading = ADC.read_raw(Flame1)
            Flame2reading = ADC.read_raw(Flame2)
            Flame3reading = ADC.read_raw(Flame3)
            print(str(Flame1reading) + " " + str(Flame2reading) + " " + str(Flame3reading ) )
            
            ScaledFlame1=translate(Flame1Reading, min1, max1, 5, 100)
            ScaledFlame2=translate(Flame2Reading, min2, max2, 5, 100)
            ScaledFlame3=translate(Flame3Reading, min3, max3, 5, 100)
            print(str(ScaledFlame1) + " " + str(ScaledFlame2) + " " + str(ScaledFlame3 ) )

            time.sleep(.01)

            lowest = min(ScaledFlame1, ScaledFlame2, ScaledFlame3)
            
            farval= 50
            closeval=20
            print("lowest: " + str(lowest))
            if lowest >= farval:
                driveCom="B"
            elif (farval >= lowest >=closeval):
                driveCom="A"
            elif lowest <=closeval:
                driveCom="F"
            ser.write(driveCom)
                
            
            time.sleep(2)
            print "made it! :)"
            #Put real driving code here, and stop at flame
            state = 6
            
    
    return state
        
